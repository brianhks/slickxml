#summary How to write a config file

= Configuration File =

First have a look at the [http://code.google.com/p/slickxml/source/browse/trunk/test/parser_config.xml sample] configuration file found in the project.

Also have a look at this mapping of a configuration file to the xml that it will parser.

[http://slickxml.googlecode.com/svn/wiki/img/config_xml_map.png] 


== Simple Example ==

Lets say we want to parse the following simple xml document
{{{
<books>
  <book name="Lord of the Rings" author="JRR Tolken"/>
  <book name="Fahrenheit 451" author="Ray Bradbury"/>
  <book name="Facing Codependence" author="Pia Mellody"/>
</books>
}}}

That is a great set of books!  Now lets parse it, or better yet lets create a config file so SlickXML can create a parser for us.  What we would like is for the parser to hand back each book to us as an object so our code can place the book in a database.

First lets start with the basic outline of the config file.  This defines the package name to use and where to place the java file.
{{{
<slickxml package="bookprocessor.parsers" destination="src/java/bookprocessor/parsers">
  ...
</slickxml>
}}}

=== Parser ===
Now we want to add a parser for our books.  The class name for the parser will be `BookParser`
{{{
<slickxml package="bookprocessor.parsers" destination="src/java/bookprocessor/parsers">
  <parser name="BookParser">
  </parser>
</slickxml>
}}}

=== Object ===
Now we will define the object to be returned to us.
{{{
<slickxml package="bookprocessor.parsers" destination="src/java/bookprocessor/parsers">
  <parser name="BookParser">

    <object name="Book" tag="book">
    </object>

  </parser>
</slickxml>
}}}
The object it will return is `Book` or more precisely it will be an instance of `BookParser.Book` in the package `bookprocessor.parsers`.  Notice we didn't have to specify the root element.  The parser basically goes through the file ignoring everything until it hits an element that matches one of its root objects, in this case `book`

=== Property ===
Now to define two properties on the object to contain each of the attributes
{{{
<slickxml package="bookprocessor.parsers" destination="src/java/bookprocessor/parsers">
  <parser name="BookParser">
    <object name="Book" tag="book">

      <property name="Name">
        <attribute>name</attribute>
      </property>
      <property name="Author">
        <attribute>author</attribute>
      </property>

    </object>
  </parser>
</slickxml>
}}}
The "property" elements tell the parser to add a member variables to the `Book` class.  The value for the two member variables will come from the specified attributes that are on the `book` element in the xml.  Now because this object only defines properties that are attributes of the start tag, the object will be returned immediately after the start element has been processed.  In this case it isn't a big deal because the book elements don't contain a body but, if they did it would make a difference.


== Example 2 ==
=== Element ===
Now lets make that XML a little more complicated and introduce a new concept
{{{
<books>
  <book name="Lord of the Rings" author="JRR Tolken">
    <isbn>123456</isbn>
  </book>
  <book name="Fahrenheit 451" author="Ray Bradbury">
    <isbn>123454</isbn>
  </book>
  <book name="Facing Codependence" author="Pia Mellody">
    <isbn>123452</isbn>
  </book>
</books>
}}}

Now there is a child element that we want to get the value of.  Again we use the `property` tag but define the content as an `element`:
{{{
<slickxml package="bookprocessor.parsers" destination="src/java/bookprocessor/parsers">
  <parser name="BookParser">
    <object name="Book" tag="book">
      <property name="Name">
        <attribute>name</attribute>
      </property>
      <property name="Author">
        <attribute>author</attribute>
      </property>

      <property name="ISBN">
        <element name="isbn"/>
      </property>

    </object>
  </parser>
</slickxml>
}}}
Now if the parser hits any child element of `book` that equals `isbn` it will be added as a property to the `Book` class.  Because elements can occur more then once, properties that are defined using the `element` tag can be retrieved one of two ways from the returned object.  In our case the `Book` object will have two get methods for `ISBN`: `Book.getISBN()` and `Book.getISBNList()`.  The first is a convenience method that returns the first ISBN in the list, where as the second returns the entire list in the order that they were parsed.

=== Condition ===
There is one more concept with the `property` element and that is conditions.  A condition is used inside an `element` so that a check for a certain attribute before grabbing the text of the element.  To explain this we will change up the XML a bit:
{{{
<books>
  <book name="Lord of the Rings" author="JRR Tolken">
    <isbn type="old">123456</isbn>
    <isbn type="new">123456-123</isbn>
  </book>
  ...
</books>
}}}
Now there are two different isbn numbers and the difference is specified in the attribute `type`.  We can separate those into two different properties with the following configuration change:
{{{
<slickxml package="bookprocessor.parsers" destination="src/java/bookprocessor/parsers">
  <parser name="BookParser">
    <object name="Book" tag="book">
      <property name="Name">
        <attribute>name</attribute>
      </property>
      <property name="Author">
        <attribute>author</attribute>
      </property>

      <property name="ISBNOld">
        <element name="isbn">
          <condition name="type" value="old"/>
        </element>
      </property>
      <property name="ISBNNew">
        <element name="isbn">
          <condition name="type" value="new"/>
        </element>
      </property>

    </object>
  </parser>
</slickxml>
}}}
We can add as many conditions as we want and they will be AND'd to gether in the code.

== Inner Object ==
You can define an inner object just as you did the object above but, you place it within another object definition.

{{{
<slickxml package="bookprocessor.parsers" destination="src/java/bookprocessor/parsers">
  <parser name="BookParser">
    <object name="Book" tag="book">
      <property name="Name">
        <attribute>name</attribute>
      </property>
      <property name="Author">
        <attribute>author</attribute>
      </property>
      <property name="ISBNOld">
        <element name="isbn">
          <condition name="type" value="old"/>
        </element>
      </property>
      <property name="ISBNNew">
        <element name="isbn">
          <condition name="type" value="new"/>
        </element>
      </property>

      <object name="AuthorAddress" tag="address">
        ...
      </object>

    </object>
  </parser>
</slickxml>
}}}
In this case `Book` now contains a member list for `AuthorAddress` objects and getter methods just like the ones for element properties.

== Recursive Object ==
Now lets get crazy with the xml.  What if the book element could contain within it another book element like this:
{{{
<books>
  <book name="Lord of the Rings" author="JRR Tolken">
    <book name="The Two Towers" author="JRR Tolken"/>
    <book name="Return of the King" author="JRR Tolken"/>
  </book>
  ...
</books>
}}}
Basically we want the parser to look for recursive objects and here is how we do it.
{{{
<slickxml package="bookprocessor.parsers" destination="src/java/bookprocessor/parsers">
  <parser name="BookParser">
    <object name="Book" tag="book">
      <property name="Name">
        <attribute>name</attribute>
      </property>
      <property name="Author">
        <attribute>author</attribute>
      </property>

      <object reference="Book"/>

    </object>
  </parser>
</slickxml>
}}}

Now the `Book` class contains getters for a list of `Book` objects.